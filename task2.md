## Задание 2

###  Домашнее задание: Прочитать в книге **PROGIT** главы 1-3 (Введение, Основы Git, Ветвление в Git), можно использовать русский печатный вариант книги, доступный в бибилиотеке и в электронном виде: **"Чакон С. Git для профессионального программиста"**, единственное отличие первая глава называется "Начало работы", в не "Введение". Книги в электронном виде можно найти в репозитории в разделе "wiki/Библиотека/Git".

## Работа с ветками в Git через консоль

Перед выполнением задания необходимо выполнить [настройку виртуальной машины для работы с системой управления проектами и клонирование своего существующео проекта в виртуальную машину](task_vm_prepare.md)

Вы можете всегда использовать указанные инструкции для подготовки виртуальной машины в новой аудитории или на новом компьютере.

Откройте терминал, вся дальнейшая работа будет выполняться в нем.

Необходимо перейти в каталог с вашим проектом, если вы делали все по инструкции, то путь к вашему проекту '/home/user/Desktop/tpro'

Узнать текущий каталог можно выполнив команду 
```
pwd
```
Если находитесь в другой директории выполните команду:
```
cd ~\Desktop\tpro
```
Выполните последовательно две команды:
```
ls
cat README.md
```
На экране вы должны увидеть сначала список скачанных файлов вашего проекте, затем содержимое файла README.md, убедитесь что выработаете со своим проеком по содержимому файла. 

### Работа с ветками через консоль

В данном задании будет выполнены все теже действия, что и в предыдущем [задании](task1.md), отличие лишь в том, что в певом случае вы работали через веб-интерфейс системы управления проектами, а теперь  будем работать с системой контроля версий через консоль.

Теперь давайте узнаем ветку в которой мы сейчас находимся. Это можно сделать с помощью следующей команды:
```
git status
```
Результат должен быть примерно следующим
```
On branch master
Your branch is up to date with 'origin/master'.

nothing to commit, working tree clean
```
Что означает, что текущее состояние проекта совпадает с состоянием проекта по условному адресу 'origin' и веткой 'master', а также что нет никаких изменений, которые необходимо фиксировать (commit).

Узнать что скрывается за условным адресом 'origin', можно выполнив команду:
```
git remote -v
```
Так как мы работаем с существующим проектом, в котором по предыдущему заданию создавались ветки, то в нём существует ещё 3 ветки: branch1, branch2 и branch3. 

Выполните команду, которая выведет ветки проекта
```
git branch
```
Должен появиться список веток, звёздочка означает текущую выбранную ветку. Но почему тогда всего 1 запись (master), а не 4? Потому из репозитория забирается по-умолчанию, в данном случае  master.

Теперь переключимся на ветку branch1.
```
git checkout branch1
```
Результат буде примерно таким:
```
Switched to a new branch 'branch1'
Branch 'branch1' set up to track remote branch 'branch1' from 'origin'.
```
Что означает, что произошло переключение на новую ветку 'branch1', и эта ветка подключена к одноименной ветке проекта с условным адресом 'origin'. Можете проверить доступные ветки проекта командой 'git branch'.

Аналогично теперь переключитесь на ветку branch2 и branch3.

Переключитесь на ветку 'master'

Посмотреть графическое представление веток через консоль можно выполнив команду (указанные ключи делают вывод наглядным):
```
git log --oneline --decorate --graph --all
```
или
```
gitk
```
Выйти из режима отображения команды git log можно клавишей "q" или "Ctrl-C".

Обратите внимание при запуске gitk, работа в консоли не может быть продолжена пока не закрыто окно gitk.

В последнем случае откроется отдельное окно.

Теперь приступим к основным задачам задания - созданию веток через консоль, задачи те же что и в предыдущем задании:

* Слияние при изменениях только в одной ветке - конфликта не должно возникать
* Слияние при пересекающихся изменениях в двух ветках - необходимо разрешить конфликт
* Слияние при непересекающихся изменениях в двух ветках - конфликта не должно возникать

**Ветка 2_1 - слияние при изменениях только в одной ветке**

* Создадим ветку c именем "branch2_1". Для этого выполним следующую команду: 
``` 
git checkout -b branch2_1 
```
Вывод будет следующим:
```
Switched to a new branch 'branch2_1'
```
После выполнения данной команды мы работаем с новой веткой branch2_1 и она является копией ветки main, включая текущий последний коммит, при любых последующих изменениях ветки main и branch2_1 'разойдутся'. Посмотрите текущее графическое представление веток командами 'git log ...' c ключами, указанными выше или 'gitk'.

* Теперь откройте веб-интерфейс и посмотрите список доступных веток (Графическое представление Repsitory-Graph или список веток Repository-Branches). Ветка branch2_1 ещё не отображается, потому что мы не сообщили серверу о внесённых изменениях. Это можно осуществить с помощью следующей команды:
```
git push origin branch2_1
```
В консоли вы увидите следующее:
```
Total 0 (delta 0), reused 0 (delta 0)
remote: 
remote: To create a merge request for branch2_1, visit:
remote:   https://gitwork.ru/username/tpro/-/merge_requests/new?merge_request%5Bsource_branch%5D=branch2_1
remote: 
To gitwork.com:username/tpro.git
 * [new branch]      branch2_1 -> branch2_1
```
Последняя строка нам сообщает, что ветка была успешна создана, теперь она доступна на выбор через веб-интерфейс. Проверьте этот факт.

* Откройте файл README.md с помощью текстового редактора. Это можно сделать с помощью следующей команды: 
``` 
nano README.md
```
Здесь и далее будут приведены действия для редактора nano, при использовании другого редактора, используйте соответствующие команды и сочетания клавиш.

Добавьте в файл следующую строку : "Add in branch2_1". Сохраните изменения в файле (Ctrl+S), закройте редактор (Ctrl+X). Все изменения, которые вы производите, производите локально, удалённый сервер ещё ничего не знает о внесённых вами изменениях. Давайте сообщим серверу о внесённых изменениях.

* Не забывайте в процессе изменения файлов периодически выполнять команду ```git status``` чтобы узнать текущее состояние проекта.

* Выполните следующие команды:
```
Сообщаем системе контроля версий, что следует индексировать данный файл

git add README.md

Зафиксируем изменения и подготовим к передаче на сервер

git commit -m "Modified README.md in branch2_1"

Далее запросим изменения с сервера. Может получиться так, что с веткой одновременно работает несколько человек и ваша локальная копия файлов отличается от актуальной копии данных на сервере. Все изменения необходимо забрать для локального использования

git pull origin branch2_1

Так как изменений на сервере не было, а внесённые нами изменения были добавлены в коммит, то изменений локальных файлов не произойдёт. Осталось только отправить наши изменения на сервер.

git push origin branch2_1

После этого обновите веб-интерфейс, перейдите на ветку branch2_1. Вы увидите, что теперь наши изменения отображаются на сервере.
```
Обратите внимание, содержимое файла на сервере для веток master и branch2_1 отличается.

* Теперь после фиксации изменений сольём две ветки: master и branch2_1. Так как мы хотим забрать изменения из ветки branch2_1 в ветку master, то переключимся на ветку master. Это можно сделать с помощью команды 
```
git checkout master
```
Теперь вы работаете с веткой master и можете забирать изменения. Это можно выполнить следующей командой 
```
git merge branch2_1
```
Мы сообщили ветке master, что изменения надо забрать из ветки branch2_1. Теперь можно наблюдать, что в файле README.md появилась новая запись из ветки branch2_1 (проверить можно командой ```cat README.md```). 

* Теперь необходимо сообщить серверу о внесённых изменениях в ветку master.
```
git push origin master
```
Обновите веб-интерфейс. Вы увидите, что теперь файл README.md в ветках main и branch2_1 совпадает.

Конфликта при слиянии не было.

Графическое отображение веток может не совпадать с вариантом предыдущего задания для ветки branch1, это означает, что система контроля версий не обнаружила изменений в ветке masterи для экономии не создала новый коммит, а просто переместила указатель ветки master на место указателя ветки branch2_1.

**Ветка 2 - слияние при пересекающихся изменениях в двух ветках**

* Сейчас мы работаем в ветке master. Создадим новую ветку branch2_2. Это можно сделать с помощью команды 
```
git checkout -b branch2_2
```
Выполним команду ```git status``` и действительно увидим, что теперь работаем с новой веткой branch2_2. 

* Сообщим серверу о созданной ветке командой
```
git push origin branch2_2
```
Вы должны увидеть сообщение о успешно добавленной новой ветке.

* Внесём изменения в файл README.md, добавьте строку следующего содержания "Add in branch2_2". Теперь добавим изменения на сервер (работаем светкой branch2_2).
```
git add README.md

git commit -m "Modified README.md in branch2_2"

git push origin branch2_2
```
* Теперь переключитесь на ветку master и добавьте туда запись следующего вида: "Add in branch master". Отправьте измения на сервер, команды для указанных действиям аналогичны указанным выше, с указанием ветки master.

* Проверьте графическое представление веток проекта через консоль ```git log ...``` , ```gitk``` или через веб-интерфейс.

* Приступим к слиянию веток. Находясь в ветке master выполним команду на слияние веток
```
git merge branch2_2
```
Вывод будет следующим:
```
CONFLICT (content): Merge conflict in README.md
Automatic merge failed; fix conflicts and then commit the result.
```
Что означает, что в файле README.md обнаружен конфликт слияния и авотматическое слияние невозможно, необходимо устранить конфликт, для этого откроем в редакторе файл README.md и увидим следующее:

```
Начало файла пропущено....

<<<<<<< HEAD
Add in branch master
=======
Add in branch2_2
>>>>>>> branch2_2
```

Место начало конфликта указывается с помощью `<<<<<<< HEAD`. HEAD - указывает на текущую ветку, то есть master. Черта из знаков `=======` показывает отличия в двух ветках. Снизу метка `>>>>>>> branch2_2` показывает место окончания конфликта и то, что конфликт был при слиянии с веткой branch2_2. 

* Разрешим конфликт, уберем знаки обозначения конфликта и оставим один вариант с branch2_2:

```
Начало файла пропущено....

Add in branch2_2
```
Как видно в отличие от веб-интерфейса при разрешении конфликта через консоль можно внести дополнительные изменения, а не только выбрать один из начальных вариантов.

* Если вызвать команду ```git status```, то можно увидеть информацию о текущем состоянии проекта, что есть незаконченное слияние и изменения затрагивают теперь обе ветки, необходимо выполнить фиксацию изменений:
```
On branch master
Your branch is up to date with 'origin/master'.

You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)
        both modified:   README.md

no changes added to commit (use "git add" and/or "git commit -a")
```
Выполним фиксацию изменений и отправим их на сервер
```
git add README.md
git commit -m "fixed merge conflict"
git push origin master
```
Слияние веток branch2_2 и master завершено.

**Ветка 3 - слияние при непересекающихся изменениях**

* Создайте ветку `branch2_3`, отправьте информацию об этом на сервер

* Измените файл README.md - в строке "Add in branch2_1" добавьте "modified in branch2_3". Сохраните файл и отправьте изменения на сервер с комментарием "README.md updated in branch2_3".

* Переключитесь на ветку master

* Измените файл README.md - в строке "Add in branch2_2" добавьте "modified in master". Сохраните файл и отправьте изменения на сервер с комментарием "README.md updated in branch master".

* Сравните содержимое файла README.md в ветках master и branch2_3. (Через консоль переключаясь между ветками и выводя файл командой `cat` или через веб-интерфейс)

* Проверьте что находитесь на ветке master и при необходимости переключитесь на нее.

* Проведите слияние с веткой branch2_3. Если вы выполните просто команду `git merge`, то система попросит вас ввести комментарий к коммиту открыв редактор по умолчанию, в нем уже будет сообщение "Merge branch branch2_3", можете не вносить изменений просто закройте редактор (Если это редактор nano, то Ctrl-S, Ctrl-X, но возможно это редактор VIM, тогда нажав клавишу Shift и не отпуская ее, два раза нажмите Z ... Shift-Z-Z)

Избежать работы с редактором можно если изначально передать сообщение команде merge:

```
git merge -m "Merge branch branch2_3" branch2_3
```
На экране вы должны увидеть следующий вывод:
```
Auto-merging README.md
Merge made by the 'recursive' strategy.
 README.md | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
```

* Отправьте изменения на сервер:
```
git push origin master
```

* Если ошибок не было допущено, то слияние должно было пройти без конфликта

* **Проверьте итоговое состояние проекта через веб-интерфейс или консоль - все ветки должны быть слиты с основной веткой master**

## Сдача задания

Для сдачи задания в **своем проекте** создайте issue "Сдача task2" и приложите туда скриншоты графического представления веток из веб-интерфейса и из консоли (или gitk). Скриншот должен включать по времени участок проекта, посвященный текущему заданию. Назначьте получателем (Assignee) для issue своего преподавателя.

Если issue будет закрыто, то задание принято, в противном случае преподаватель укажет замечания в issue и переназначит его вам.





