## Задание №3
## Командная работа

### Лирическое отступление
При разработке программных продуктов широко распространена практика командной работы. Небольшие программы возможно разработать в одиночку, но требования по скорости разработки и объёму функционала зачастую диктуют необходимость участия нескольких специалистов в различных областях знаний. Программист и дизайнер - это уже команда из двух человек, которым необходима коммуникация. С увеличением числа задействованных специалистов возрастают требования к инструментарию, облегчающему взаимодействие.

Пофантазируем — представим, что вы разрабатываете IT-продукт по продаже **корма для собак**. На данный момент вы в команде один. Что вы будете делать в первую очередь? Вы задались идеей и, вполне вероятно, что даже составили небольшой и довольно грубый план. Вы решаете, что вам необходимо приложение под платформу Android, так как вы прекрасный специалист в области мобильной разработки на Android (а почему бы и нет). Спустя несколько долгих месяцев работы оказывается, что вы даже немного смыслите в дизайне, и ваше приложение выдалось вполне удачным. Вы получили первых клиентов (а может и не получили) и осознали, что больш**а**я часть потенциальных клиентов "обитает" на платформе iOS. Что вы будете делать теперь?

Что ж, вы прошли через многое и считаете, что изучить язык программирования Swift и новую платформу для вас совсем не проблема. Вы тратите ещё какое-то время на это и вуаля! У вас есть приложение по продаже корма для собак под две основные платформы, и теперь дела должны идти в гору, как никогда раньше. Но... как обычно, всё не так гладко. Оказывается, что пока вы реализовывали приложение под iOS, пользователи на Android начали стремительно понижать рейтинг приложению из-за множественных ошибок и багов. Теперь вы не спите ночами, исправляя все баги и уверяя пользователей, что теперь всё работает прекрасно...пока ваше приложение на iOS вдруг не упало. 

Хорошо, просидев за разработкой ещё какое-то время, вы сделали приложение довольно стабильным. Теперь пора расширяться, ведь конкуренты не дремлют: они сделали себе прекрасный сайт, в связи с чем их количество клиентов существенно выросло! Вы тоже хотите себе сайт, но кто его сделает? Вы не успеваете исправить все баги на мобильных платформах, так ещё и собираетесь сайт сами разрабатывать? Наконец, вы осознаете, что вам нужна помощь **специалиста в разработке web-сайтов**. Вам нужен кто-то, кто будет следовать той же цели, что и вы, забрав у вас сравнительно большую зону ответственности. Теперь вы приветствуете нового члена вашей команды, который будет отвечать за web-разработку и частично заберет на себя проблемы с продвижением продукта.

Теперь у вас есть приложение под две мобильные платформы, ваш web-сайт и **команда из двух человек** — что дальше? Вы **расширяете** ассортимент. Теперь вы продаёте корм для кошек, хомяков, птиц и т.д. У вас появилось огромное количество данных о поставщиках, продажах, продуктах и даже о покупателях! Вы всё ещё храните данные в одном файлике? Теперь нет. Вы нанимаете в команду **специалиста по базам данных**. **Команда расширилась до трех человек**. Данных стало в разы больше, но и то, как это работает, вас теперь тоже не волнует — для этого есть свой специалист. Вас волнует лишь то, что обращения к вашей базе должны быть максимально быстрыми, а данные не потерялись в случае непреднамеренного сбоя.

Пройдут годы, ваш продукт расширится максимально: вы наймёте **аналитиков**, чтобы предлагать покупателям товары, которые наверняка им подойдут (рекомендательные системы); вы наймёте **дизайнеров**, чтобы улучшить внешний вид ваших приложений; вы наймёте **тестировщиков**, ведь кто-то должен ещё, помимо клиентов, проверять насколько плохой у вас программный продукт; вы будете нанимать всё **больше и больше сотрудников**, расширяя способности и сферы деятельности вашего продукта. Вы будете продолжать это делать, если это будет способствовать успеху вашего продукта.

Что по итогу? Просто вспомните с чего вы начали. Совсем редко когда успешные продукты создаются и поддерживаются одним человеком. Вы не всесильны, поэтому вы просто **обязаны** научиться разделять задачи и работать в команде, состоящей из специалистов различных областей.

### Основная часть

Большинство программных продуктов используют специальные разработанные средства и методологии для ведения удобной, масштабируемой и эффективной командной разработки.

> **Совет**: почитать про Agile и Scrum и соответствующие системы ведения проектов и отслеживания ошибок, к примеру, 
> YouTrack и Jira.

В текущем задании мы упростим процесс ведения проектов до использования только одной системы управления проектами GitLab, с которой вы уже знакомы. Это не говорит о том,
что различные описанные средства не используются в командах из 2-3 человек (скорее наоборот, в основу фреймворка Scrum, 
поддерживаемый, к примеру, Jira, легла идея небольших команд из 3-9 человек), однако для работы в текущих реалиях этого 
более, чем достаточно.

GitLab поддерживает основные инструменты ведения командной разработки: 
* **issues** - задачи, по разработке кода или исправлению ошибок и т.п.
* **MR** (merge requests) - запросы на слияние - внесение подтвержденных изменений в проект,
* **ветки** (branches) - разделение проекта на различный функционал или тестирование отдельных возможностей до внедрения в основной проект
* и даже подобие **Kanban-досок**, часто используемые в командной разработке для наглядного отображения процесса разработки. 

### Цель
В этом задании необходимо изучить основные аспекты работы с ветками, issues и merge requests, а также канбан-досками на основе issues в GitLab, применяя это всё в командной разработке.

### Ход занятия

1. Создайте в своем личном проекте каталог task3, здесь будет вестись работа над данным заданием, помещаться редактируемый код и другая информация относящаяся к заданию. Для удобства сразу создайте issue "Сдача task3", но не назначайте его преподавателю. Помещейте в него скриншоты, относящиеся к выполнению задания, и как только задание будет выполнено, назначьте issue преподавателю.

1. **Задача 1**. Перед началом работы вам **необходимо** добавить в свой проект **следующего по списку** слушателя (n+1) с учетом посещаемости занятия, возможно это будет n+2 и так далее, с которым вы будете пробовать командную работу над проектом. Вашего одногруппника необходимо добавить с правами **Developer** (подробнее о ролях в проекте можете почитать по ссылке рядом с назначением роли), чтобы он мог создавать MR-запросы (Merge request). Не волнуйтесь, что он может что-то изменить в вашем проекте: любые изменения в репозитории будут видны в коммитах. На **скриншоте** показать всех членов вашего репозитория (Project information -> Members). 
   
1. **Задача 2**. Аналогично **Задаче 1** проверьте, что **предыдущий по списку** слушатель (n-1) добавил вас в свой проект с правами **Developer**. Это потребуется для дальнейшего выпонения задания. На **скриншоте** показать всех членов репозитория слушателя (n-1), где видна ваша роль (Project information -> Members). 

1. Теперь, когда у вас с вашим напарником есть настроенный проект, давайте поговорим о том, как следует вести совместный проект и как принято их вести в современном IT-мире. Мы будем проводить некую параллель с часто используемой в IT-проектах методологией **Agile**, чтобы вы могли действительно осознать, что мы не занимаемся абстрактными ненужными вещами. Естественно, всё изложенное в этом задании является некоторым упрощением реальных процессов обсуждения проблем, ведения репозиториев, процессов руководства командой и т.п., но даже это достаточно для того, чтобы **разумно** вести командную разработку.
   
1. Итак, вернемся к [началу](#лирическое-отступление) и вашему зоомагазину. Допустим, у вас уже имеется Android-приложение и сейчас вам нужно предугадать некоторые пожелания ваших клиентов или, возможно, подумать какой функционал вы хотели бы добавить в приложение. В Agile и Scrum подобные пожелания принято называть **пользовательскими историями**, а то, куда эти истории помещают - **бэклогом**. По-простому, это подобно случаю, когда вы продумываете на человеческом языке функции, которые должна выполнять ваша программа, и записываете все ваши мысли (пользовательские истории) в специальный блокнот (бэклог). Впоследствии при разработке программного средства вы выбираете нужные вам истории в порядке приоритета исполнения из вашего бэклога и превращаете их в формализованное задание.Формализованное задание переводит простые мысли и пожелания клиента (те самые пользовательские истории) в удобный и понятный для разработчика язык: в задании чётко пишется то, что необходимо сделать конкретному разработчику; за какой срок; в каком виде и т.п. Очевидно, что одна пользовательская история может подразумевать сразу несколько заданий. К примеру, история "Добавить возможность оставлять отзыв о товаре" может подразумевать сразу несколько заданий: "Разработать дизайн окна отзывов", "Добавление таблицы отзывов в базу данных", "Реализация диалогового окна отзывов" и т.п., каждый из которых назначается **своему отдельному** исполнителю в **команде разработки**.
   
1. В GitLab нет поддержки бэклога, пользовательских историй и заданий в удобном виде, потому что для этого есть специальные средства типа Jira (которое, кстати, интегрируется с GitLab и позволяет с лёгкостью взаимодействовать между этими двумя продуктами). Однако, функционал **Issues** и **Kanban-досок** (Issues->Boards) практически полностью могут покрыть этот недостаток.
   
   > Перед тем, как перейти к следующему пункту, важно уточнить, что бэклог используется в т.ч. для так называемых **спринтов**.
   > И на самом деле, процесс использования всех этих технологий куда сложнее. Но для этого, опять же, необходимо подробнее ознакомиться со Scrum и Jira.
   
1. Откройте вкладку Issues->Boards слева на панели проекта. Перед вами подобие **Kanban-доски**, которая используется для удобного распределения тасков по их состоянию. Сейчас, скорее всего, у вас только два столбца **Open** и **Closed**, в которые GitLab автоматически помещает открытые и закрытые issues. 
   
   В реальных проектах такие Kanban-доски используются постоянно, разве что в Jira они конкретно предназначены для заданий, а не issues, как в GitLab, но логика абсолютно та же. Доски нужны для того, чтобы руководителям проекта, а также и членам проекта было удобно наблюдать за состояние дел по его разработке. На доске отображаются задания, которые ожидают начала работы, находятся в работе, на code review, на тестировании, завершённые и т.д. Количество таких столбцов варьируется от проекта к проекту и полностью определяется **рабочим процессом** задач — это некоторый конвейер, через который проходит любая задача от начала (колонка "Ожидает начала работы") и до конца (колонка "Завершена"). Рабочий процесс можно полностью изменить — этим занимается руководитель проекта.
   
1. На рисунке представлен самый простой схематичный пример Kanban-доски. **Бэклогом** мы по сути можем называть то, что определено в столбце "Сделать". Важно только помнить, что бэклог — это всё-таки перечень задач, расположенных в порядке важности, для команды разработчиков, а на Kanban-доске такие задачи не всегда располагаются именно по приоритету. 
   Для простоты давайте считать бэклогом просто "список дел" по всему проекту, упорядоченных по приоритету, а столбец "Сделать" на доске в свою очередь может содержать ещё и другие **сопутствующие какой-либо истории из бэклога** задания.

   ![Kanban-доска](img/kanban.png)

1. Сейчас на вашей Kanban-доске всего два столбца. Вы всегда можете изменить количество столбцов, добавив новые. Однако, 
   GitLab создаёт столбцы только на основе **меток** (labels) у issues проекта. Поскольку, изначально у вас нет ни единой метки, 
   создать новые колонки у вас не получится.
   
   **Задача 3**. Создайте метки **backlog**, **code review** и **bug** (Меню Issues -> Labels).  Первая метка понадобится для реализации бэклога, описанного ранее. Вторая метка нужна для тех issues, которые вы создаёте, желая, чтобы ваш участок кода был проверен кем-то из ваших членов проекта (обычно этим занимается Team Lead проекта или иной старший разработчик). Третья метка нужна для тех issues, которые говорят о наличии ошибки (bug) в каком-либо участке кода. Выберите для каждой метки свой цвет и добавьте описание, что значит конкретная метка. Создайте **новую** Kanban-доску (Issues -> Boards), назвав её вашим **fullname** (близко 
   к левой панели есть **выпадающее меню** рядом с поисковой строкой **"Search or filter results"**, там нажать на **Create new board**). Создайте на ней новых 3 столбца из созданных ранее меток (в правой верхней части кнопка **Add list** (всего у вас должно быть 5 столбцов).
   
1. Итак, теперь у вас есть своя собственная Kanban-доска, на которой вы с вашим напарником можете вести совместную разработку
   через issues. Теперь вкратце разберем и попрактикуемся на каждой отдельной метке. Начнём с **бэклога**.
   
   Ниже представлено несколько вариантов возможных приложений:

   1. Мобильное приложение для зоомагазина
   2. Мобильное приложение для ставок на спортивные события
   3. Мобильное приложение для онлайн-магазина одежды
   4. Сайт для анонимного общения
   5. Десктоп приложение для ведения проектов команд разработки
   6. Телеграм-бот для поиска книг
   7. Сайт для онлайн-курсов
   8. Приложение на смарт-часы для сна
   
   **Задача 4**. Ваш вариант: `<номер_по_списку> % 8` (очевидно, что для 8-го, 16-го и т.д. — это 8-й вариант). Теперь уточните вариант одногруппника, идущего **перед** вами по списку (n-1), и составьте **3 пользовательских историй** с меткой **backlog** в его проекте для его приложения: опишите то, что вы хотели бы видеть как **клиент**. Перейдите в ваш **собственный** проект и посмотрите на доску: если ваш напарник (n+1) сделал всё правильно, то вы должны увидеть 3 открытых issues с меткой **backlog** на вашей доске. Вы можете перейти в каждый из открытых issues и ответить на них. **Важно** не забыть при создании issues вашему напарнику назначить роль исполнителя (assignee) на **него**. На **скриншотах** необходимо показать Kanban-доску **слушателя (n-1)**, на которой видны ваши issues, а также сами issues и их содержимое. 
   
   **Задача 5**. Теперь создайте **собственный** issue, в котором попробуйте более чётко формализовать требования к вашему приложению (возьмите одну из 3-х историй, которые вам прислали). Не забудьте закрыть issue с меткой **backlog**, которую вы трансформировали в открытый issue. Что ж, теперь у вас на доске должно быть открыто 1 issue, 2 в поле  **backlog** и 1 в поле **closed**. Вы можете представить, что вы закрыли одну из задач и спокойно перенести ваш issue из поля **open** в поле **closed**. На **скриншотах** необходимо показать **вашу** Kanban-доску, на которой уже есть одно закрытое issue, а также показать описание созданного вами нового **issue**.
   
   Теперь должны иметь примерное представление о работе с **задачами** и бэклогом, непосредственно использующиеся при любой командной разработке. **Важно понять**, что на самом деле никто, конечно, меток **бэклог** не создаёт. Но при всём этом, правила ведения вашего проекта вы устанавливаете сами. Поэтому, вы вольны творить всё 
   что угодно, лишь бы это было удобно всем членам команды.
   
1. Работа с Kanban-досками и issues, естественно, довольное интересное занятие, но в командной разработке есть и другие важные средства для достижения общей цели. Сейчас мы поговорим о запросах на слияние (**Merge requests**) и то, зачем они нужны.

   Представим, что вас обязали разработать или переработать какую-то часть вашего общего приложения. Вы создали отдельную ветку в репозитории с соответствующим названием, потратили какое-то время, выполнив задание, а сейчас хотите внести изменения в существующий проект, тем самым "слив" вашу ветку с веткой **master** или **main** (раньше все главные ветки по-умолчанию назывались master, но волна "толерантности" добралась даже до этого). Что будем делать —  просто слить ветки? Боюсь, что такого вам в реальных проектах сделать не позволят (хотя бы потому что обычно изменения в мастер-ветку могут вносить только определенные разработчики), а вот запрос на слияние (merge request) вы создать всегда сможете!
   
1. Итак, зачем же всё-таки нужны MR? Вкратце: для того, чтобы вы командой разработки могли обсудить изменяемый в главной ветке код, как-то его прокомментировать, найти проблемы и изъяны, а затем решать — вносить изменения или нет. Ну, то есть формально MR используется для некоторого рефакторинга (изменения) кода — вносятся новые участки кода или изменяются старые.
   
   > Важно сказать, что в GitLab запросы на слияние принято называть "Merge request", в то время как в GitHub и BitBucket 
   > установлено название "Pull request" (или PR). Естественно, концептуально они никак не отличаются. 
   > Вы можете называть их как угодно. В рамках задания мы будем говорить конкретно о Merge requests, поскольку мы работаем с GitLab.
   
   Всю процедуру MR условно можно представить в виде такой последовательности действий:  
   
   1. Получение нового задания на изменение какого-то участка кода или функционала (в виде нового issue)
   2. Создание новой ветки для внесения изменений
   3. Внесение изменений и "push" в эту ветку
   4. В Web-интерфейсе создаём MR и запрашиваем слияние вашей ветки в ветку основной разработки (обычно master)
   5. Обсуждаем слияние с членами команды разработки, получаем от них некоторый ответ (в виде комментариев в MR к конкретным строчкам кода или всему MR в целом)
   6. Отменяем слияние и делаем правки, которые обсудили на 5-м шаге, в нашей ветке
   7. Шаги 4-6 повторяем до тех пор, пока слияние не будет разрешено
   8. Принимаем MR и удаляем созданную ветку разработки (путём выбора галочки delete branch при слиянии)
   

1. **Задача 6**. Теперь давайте запросим нашего напарника по проекту (n+1) помочь нам с рефакторингом. Загрузите файл с любым реализованным вами кодом в каталог task3(можно использовать участок программы, подготовленной вами на вводном занятии).  **Создайте** issue с меткой **Code review**, поставьте его исполнителем, а в issue опишите где лежит файл с которым необходимо работать. 
2. 
   Ваш напарник **должен** создать ветку с названием "N-fullname", где N - это номер issue для автоматической связи MR и задачей, внести изменения в код (добавить комментарии, изменить код, названия переменных, а просто превосходно будет, если он найдёт в коде ошибки и опишет их при MR) и сделать запрос на слияние в вашу основную ветку. Посмотрите изменения, которые он сделает, обсудите их через сообщения и решите: сливать или нет. **Не забудьте** проделать те же действия самим для человека n-1 по списку.
   После всех слияний не забудьте удалить ветки. На **скриншотах** необходимо показать созданное **вами** issue в своем проекте для другого слушателя, где видна метка, описание issue и исполнитель. Также необходимо показать открытый запрос на слияние от слушателя (n+1) с обсуждением участка кода, который он рефакторит. Сделайте ещё один скриншот, где видно сделанный **вами** запрос на слияние для слушателя (n-1) с обсуждением **его** участка кода. Приведите скриншот файла с изменениями (содержимое коммита после успешного слияния или вкладка Repository-Compare, в который выбрать свою ветку и ветку с предложения изменений).
   
1. В GitHub и GitLab есть специальная кнопка с названием **Fork** (вилка, ответвление). **Fork** — это механизм, позволяющий сделать копию репозитория, в котором вы эту кнопку нажимаете, в своём профиле. Это по сути своей полностью аналогично созданию новой ветке в вашем проекте. Вполне логичный вопрос, которым вы можете задаться — "а зачем?". Всё дело в том, что новые ветки вы можете создавать только будучи в роли **разработчика** этого проекта (именно поэтому вы без труда создадите новую ветку в **своем** проекте). Но что, если вы захотите внести изменения в какой-нибудь opensource проект на GitHub или GitLab? Вот тут вам и поможет кнопка **Fork**. Она копирует весь проект к вам в профиль, а вы можете делать с этим проектом всё что угодно. После внесения каких-либо изменений, вы можете отправить разработчику всё тот же **запрос на слияние**, а он в свою очередь, оценив ваши старания и доводы, либо примет его, либо попросит доработать.
   
1. Идея форков и слияний напрямую граничит с идеей opensource проектов: именно так разрабатываются крупные продукты и библиотеки, которым элементарно нет равных в своей нише. Делая форк и отправляя запрос на слияние другим разработчикам в сети, вы получаете не только бесценный опыт (который безусловно ценится во всех командах IT-сферы), но и участвуете в развитии opensource сообщества. 

По окончанию задания назначьте issue о cдаче задания своему преподавателю.

Также не забудьте закрыть все оставшиеся после выполнения задания "временные" issue и удалить "лишних" членов проекта, добавленный в рамках выполнения данного задания.