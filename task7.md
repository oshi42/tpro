## Задание №7. 

## Разработка графических приложений

> Для проведения занятия требуется документация по SFML

```bash
# настраиваем локальный apt - это одна длинная команда на 4 строки
sudo rm -rf /etc/apt/sources.list.d/* /var/lib/apt/lists/* &&
sudo truncate  --size 0 /etc/apt/sources.list &&
sudo apt-add-repository -n "deb [arch=amd64 trusted=yes] http://gitwork.ru:8080/ubuntu/18.04/apt-mirror/mirror/archive.ubuntu.com/ubuntu/ bionic main restricted universe multiverse" &&
sudo apt-get update

# выполнить несколько раз, пока не получите вывод без ошибок. В конце будет записано
# Reading package lists... Done
sudo apt-get update

# установка библиотеки
sudo apt-get install -y libsfml-dev

```


### Сдача задания

Сдача задания проводится как обычно - создаете issue "Сдача task7", наполняете его скриншотами и при необходимости комментариями, после готовности - назначаете issue преподавателю


### Библиотека SFML

SFML - "Simple and Fast Multimedia Library" - кроссплатформенная мультимедийная библиотека. С помощью данной библиотеки можно создавать полноценные графические приложения. Официальная документация представлена [на сайте](https://www.sfml-dev.org/documentation/2.5.1/) или локально на fs.

У каждого графического приложения существует главное окно - Window. В нём отображаются основные элементы взаимодействия пользователя с программой. Каждый элемент, расположенный в окне, представляет собой объект с доступным списком свойств и событий.

Событие - специальное сообщение, которое может возникать в различных точках программы при выполнении определённых условий. Событие служит для оповещения других объектов об изменении состояния текущего объекта.

Рассмотрим подробнее внутреннее устройство событий. Внутри каждого события хранится список объектов, которые мы хотим уведомить о изменении своего состояния. Каждому из подписавшихся объектов мы должны отправить одно и тоже сообщений. В момент возникновения события для каждого элемента списка вызывается функция оповещения, которая будет вызывать функции (обработчики) данного события у подписавшихся объектов. Для каждого события устанавливается интерфейс взаимодействия: тип функции и передаваемые параметры. Поэтому обработчик каждого подписавшегося объекта должен реализовывать этот интерфейс. 

При работе с графическими объектами большинство событий реализовано авторами библиотеки. Механизм событий есть реализация паттерна - "Наблюдатель".

### Установка библиотеки и запуск простейшего сообщения

Для установки библиотеки будем использовать базовый менеджер пакетов Ubuntu - apt. Установить библиотеку можно следующей командой (долна быть уже установлена действиями выше):

`sudo apt-get install libsfml-dev`

После установки библиотеки открываем Clion и дополняем CmakeList.txt. Нужно **добавить** нижеприведенные параметры 

```
set(CMAKE_MODULE_PATH "/usr/share/SFML/cmake/Modules/" ${CMAKE_MODULE_PATH}})

find_package(SFML 2.4.2 COMPONENTS graphics audio REQUIRED)


add_executable(SfmlApp task7/main.cpp)

target_link_libraries(SfmlApp sfml-graphics sfml-audio sfml-window sfml-system)
```
Как видно из файла работа должна вестись в каталоге `task7` **вашего проекта**

После этого проект готов к сборке. Добавим код-пример с официального сайта и запустим его.

```c++
#include <SFML/Graphics.hpp>

int main()
{
    sf::RenderWindow window(sf::VideoMode(200, 200), "SFML works!");
    sf::CircleShape shape(100.f);
    shape.setFillColor(sf::Color::Green);
    while (window.isOpen())
    {
        sf::Event event;
        while (window.pollEvent(event))
        {
            if (event.type == sf::Event::Closed)
                window.close();
        }
        window.clear();
        window.draw(shape);
        window.display();
    }

    return 0;
}
```

На экране отобразится окно с название "SFML works!" и зелёным кругом по середине. Разберём подробно,что происходит внутри программного кода:

1. Создаём главное окно приложения с помощью конструктора класса window. Задаём его размер и заголовок.
2. Создаём объект, который будет размещён внутри главного окна. В данном случае круг с радиусом 100. Задаём цвет объекта - зелёный.
3. Далее попадаем в бесконечный цикл, в котором проверяем открыто ли текущее окно. В случае закрытия окна пользователем программа завершит свою работу.
4. Создаём экземляр объекта события. Как говорилось раньше, события нужны для отслеживания изменения состояния объекта и уведомления всех подписавшихся объектов. Функция `window.pollEvent(event)` возвращает `True`, если очередь событий была не пуста (например, было нажатие клавиши или движение мышкой по рабочему окну). Если функция вернула `True`, то экземпляр объекта `Event` инициализировался и мы можем проверить какое именно событие произошло в системе. В данном случае проверяем событие закрытия окна.
5. Когда все события из очереди событий кончились, мы очищаем наше окно. Окно в данном случае служит областью рисования, где будут рендериться наши объекты. Следующим методом мы вызываем отрисовку нашего объекта - круг на область рисования и наконец заставляем окно отобразиться на экране.

Сделать **скриншот** окна, название которого будет совпадать с вашим fullname.

### Вывод текста на экран и обработка событий клавиатуры и мыши

В библиотеке реализован класс `Text`, с помощью которого можно выводить текстовые сообщения. С помощью свойств можно настроить выводимый текст, цвет текста, его размер, расположение текста на экране.

Рассмотрим простейший пример. Все изменения необходимо осуществлять в текущем проекте. Необходимо посчитать количество щелчков мыши и нажатий клавиатуры на главном окне. Для этого введём стандартные счётчики числа событий.

По умолчанию библиотека не работает с системными шрифтами. Необходимо явно инициализировать объект `Font`. Для этого необходимо скачать файл шрифта в формате `.ttf` или использовать один из системных шрифтов. В ОС Ubuntu шрифты хранятся в каталогах директории ```/usr/share/fonts/```. Шрифты формата `.ttf` хранятся в каталоге ```/usr/share/fonts/truetype```. После перехода по указанному пути вы увидите множество каталогов, в которых хранятся различные файлы шрифтов. Мы будем использовать один из базовых системных шрифтов `Ubuntu-Th.ttf`. Он располагается по следующему пути: ```/usr/share/fonts/truetype/ubuntu/Ubuntu-Th.ttf```. В дальнейшем вы можете использовать любой шрифт формата `.ttf` загруженный из сети Интернет.

Добавьте данный код в начало функции `main`.

```c++
int countKeyPressed = 0;
int countMouseClick = 0;
std::string keyEnteredMessage("Key Entered:");
std::string mouseClickMessage("Mouse Click:");
sf::Font font;
if(!font.loadFromFile("/usr/share/fonts/truetype/ubuntu/Ubuntu-Th.ttf")){
    return 0;
}
```

Далее создадим два объекта текста: один будет подсчитывать информацию о количестве нажатий клавиатуры, а другой количество щелчков мыши. Добавьте данный код после предыдущего фрагмена добавленного участка кода.

```c++
    sf::Text textMouse("This is Mouse",font,20);
    textMouse.setColor(sf::Color::Green);
    textMouse.setStyle(sf::Text::Bold);

    sf::Text textKey("This is Key",font,20);
    textKey.setColor(sf::Color::Red);
    textKey.setStyle(sf::Text::Italic);
    textKey.setPosition(0,50);
```

Теперь необходимо обработать нажатия клавиатуры и мыши. Для этого изменим блок обработки событий и перейдём на конструкцию `switch`

```c++
    switch(event.type)
    {
        case sf::Event::Closed:{
            window.close();
            break;
        }
        case sf::Event::MouseButtonReleased:{
            countMouseClick++;
            textMouse.setString(mouseClickMessage + std::to_string(countMouseClick));
            break;
        }
        case sf::Event::TextEntered:{
            countKeyPressed++;
            textKey.setString(keyEnteredMessage + std::to_string(countKeyPressed));
        }
    }
```

Событие `sf::Event::MouseButtonReleased` отвечает за отпускание кнопки мыши. Событие `case sf::Event::TextEntered` за нажатие и удерживание клавиши. Теперь осталось добавить отрисовку элементов на экран.

```c++
    window.draw(textMouse);
    window.draw(textKey);
```

Таким образом код функции `main` должен выглядеть следующим образом.

```c++
int main()
{
    int countKeyPressed = 0;
    int countMouseClick = 0;
    std::string keyEnteredMessage("Key Entered:");
    std::string mouseClickMessage("Mouse Click:");

    sf::RenderWindow window(sf::VideoMode(200, 200), "SFML works!");

    sf::Font font;
    
    if(!font.loadFromFile("/usr/share/fonts/truetype/ubuntu/Ubuntu-Th.ttf")){
        return 0;
    }

    sf::Text textMouse("This is Mouse",font,20);
    textMouse.setColor(sf::Color::Green);
    textMouse.setStyle(sf::Text::Bold);

    sf::Text textKey("This is Key",font,20);
    textKey.setColor(sf::Color::Red);
    textKey.setStyle(sf::Text::Italic);
    textKey.setPosition(0,50);

    while (window.isOpen())
    {
        sf::Event event;
        while (window.pollEvent(event))
        {
            switch(event.type){
                case sf::Event::Closed:{
                    window.close();
                    break;
                }
                case sf::Event::MouseButtonReleased:{
                    countMouseClick++;
                    textMouse.setString(mouseClickMessage + std::to_string(countMouseClick));
                    break;
                }
                case sf::Event::TextEntered:{
                    countKeyPressed++;
                    textKey.setString(keyEnteredMessage + std::to_string(countKeyPressed));
                }
            }
        }
        window.clear();
        window.draw(textMouse);
        window.draw(textKey);
        window.display();
    }

    return 0;
}

```
 Сделать **скриншот**, но котором количество нажатий клавиши и мыши будет совпадать с вашим номером по журналу, название окна должно совпадать с вашим fullname.

### Создание окна в произвольном потоке

Зачастую необходимо,что программа одновременно решала параллельно несколько задач. Допустим, вы являетесь пользователем мессенджера. Приложение должно одновременно обрабатывать ваши действия и отображать действия других пользователей на вашем экране(сообщения передаются по сети). Тогда перед вами возникают 2 параллельные задачи. Но выполнение программного кода происходит последовательно. Как же быть!? На помощью приходит такая абстракция, как **ПОТОКИ**.

Поток — это по сути последовательность инструкций, которые выполняются параллельно с другими потоками. Каждая программа создает по меньшей мере один поток: основной, который запускает функцию `main()`. Программа, использующая только главный поток, является однопоточной; если добавить один или более потоков, она станет многопоточной.

Потоки — это способ сделать несколько вещей одновременно. Это может быть полезно, например, для отображения анимации и обработки пользовательского ввода данных во время загрузки изображений или звуков. Потоки также широко используется в сетевом программировании, во время ожидания получения данные будет продолжаться обновление и рисование приложения.

Потоки бывают внутренние и внешние.
Внутренний поток - поток, который должен завершиться до завершения главного потока main. Даже если главный поток выполнил основную задачу, то внутренние потоки могут находиться в состоянии выполнения и это состояние важно для нас. Поэтому в конце главного потока всегда необходимо проверять завершили ли выполнение все внутренние потоки.

Внешний поток(фоновый) - полная противоположность внутреннему потоку. Можете считать,что по-сути вы запускаете отдельный процесс, в котором будете решать какую-то задачу. Главный поток и внешний поток уже никак не связаны и завершение одного потока никак не влияет на работу другого.

Далее мы будем работать с потоками, реализованными в библиотеке SFML. Поток можно создавать, запускать, ждать завершения потока и уничтожать поток. Рассмотрим простейший код, который создаёт новый поток, в котором мы пишем в консоль число от 0 до 1000.
Для этого необходимо:
1. Создать экземляр потока, передать функцию, которая будет выполняться после запуска потока
2. Необходимо запустить поток с помощью метода `launch()`
3. Вызов метода `wait()` заставляет главный поток остановиться и дождаться завершения созданного потока. Продолжение выполнения главного потока продолжиться после окончания выполнения потока `newThread`

```c++
void NewThreadFunc(){
    for(int i = 0; i < 1000; i++){
        std::cout << i << std::flush;
    }
}
int main()
{
    sf::Thread newThread(NewThreadFunc);
    newThread.launch();
    newThread.wait();
    std::cout << "New Thread terminated";
    return 0;
}
```

В новых потоках вы также можете не только обрабатывать какие-то данные, но также создавать графические окна и взаимодействовать с ними.
Рассмотрим простейший пример, перенесём создание нового окна в отдельный поток и запустим программу. Таким образом мы вынесли логику создания главного окна в отдельный поток.

```c++
void NewThreadFunc(){
    sf::RenderWindow window(sf::VideoMode(200, 200), "SFML works!");
    sf::CircleShape shape(100.f);
    shape.setFillColor(sf::Color::Green);
    while (window.isOpen())
    {
        sf::Event event;
        while (window.pollEvent(event))
        {
            if (event.type == sf::Event::Closed)
                window.close();
        }
        window.clear();
        window.draw(shape);
        window.display();
    }
}
int main()
{
    sf::Thread mainThread(NewThreadFunc);
    mainThread.launch();
    mainThread.wait();
    std::cout << "New Thread terminated";
    return 0;
}
```

Важно!!! Работать и обрабатывать события окна можно только в том потоке, в котором он был создан. Обработка событий окна должна происходить постоянно, потому что события хранятся в очереди событий и если вы их не будете обрабатывать, то очередь будет рости и пожирать системные ресурсы. Но что,если вы создали окно в одном потоке, а хотите обрабатывать события в другом потоке. Для этого в библиотеке `SFML` у объектов `Window` существует метод `setActive()`,который позволяет открепить окно от текущего потока и передать его другому потоку.

Перед передачей окна другому потоку вы должны сделать окно неактивным для текущего потока. Это можно сделать следующим образом. Представим что у нас уже есть созданый экземляр окна и мы хотим осуществлять обработку его событий в другом потоке.

```c++
void PollEventFunc(sf::RenderWindow & window){
    window.setActive();// делает окно активным для текущего потока
    while (window.isOpen())
    {
        sf::Event event;
        while (window.pollEvent(event))
        {
            if (event.type == sf::Event::Closed)
                window.close();
        }
        window.clear();
        window.draw(shape);
        window.display();
    }
}

window.setActive(false);// теперь окно неактивно для текущего потока
// должна быть подключена библиотека thread
sf::Thread newPollThread(PollEventFunc,std::ref(window));
newPollThread.launch();
newPollThread.wait();//ожиданием завершения потока, т.е закрытия окна.
// Если вы хотите продолжить работу в этом потоке после завершения потока newPollThread,то должны снова сделать окно доступным для текущего потока.
window.setActive();
```

### Задание

Необходимо отобразить набранный текст с клавиатуры на экран.

Событие обработки нажатия клавиш клавиатуры предоставляет достук к экземпляру объекта `text`, который содержит поле `unicode` являющееся числовым кодом нажатой клавиши. Доступ к числовому коду вы можете получить с помощью написания следующего кода ```event.text.unicode```. Для отображения на экране необходимо с помощью кодировки `Unicode` переводить числовые коды в соответствующие текстовые символы. Код клавиши Backspace = 8.

1. Необходимо отображать на экране вводимый текст с клавиатуры. Для вывода текста на экран использовать экземпляр объекта `sf::Text`, как это было в примере выше. Сделать **скриншот**, на котором введён ваш fullname.
2. Необходимо реализовать обработку нажатия клавиши `DELETE`. После нажатия данной клавиши должна удаляться последняя буква отображаемого на экране текста.
3. При вводе пользователем слова **"window"** открывать новое окно, название которого должно совпадать с вашим fullname. В момент появления нового окна события главного окна не должны быть доступными(смотрите указания ниже). На **скриншоте** продемонстрировать 2 созданных окна, дочернее окно должно иметь название: "fullname-текущая дата"

Для выполнения пункта 3 необходимо:
1. Сделать главное окно неактивным для текущего потока.
2. Создать новый поток, которому одним из параметров передать главное окно для обработки событий (передавать окно по ссылке,как в примере выше). Как говорилось ранее, обработка событий должна происходить всегда. Для этого достаточно просто извлекать событие в новом потоке, обработку событий главного окна в новом потоке не проводить!
3. После закрытия нового окна сделать главное окна неактивным для нового потока
4. После передачи управления главному потоку сделать окно снова активным для главного потока.

### Домашнее задание. Материал для самостоятельного изучения

В данном пункте будут рассмотрены некоторые объекты библиотеки, с которыми вы можете столкнуться при выполнении долгосрочного задания.

Начнём с небольшого введения. Вы должны понимать, что любой объект(геометрическая фигура, контейнер, список и т.п.) строится всегда на базе простейших геометрических фигур. Форма геометрической фигуры может быть произвольной. Например, часто при использовании сторонних программ вы взаимодействуете с такими объектами,как кнопки, поля ввода и т.п. Каждый из этих объектов внутри себя состоит из простейших фигур. Например, кнопка - это прямоугольник,внутри которого вы размещаете объект Text. Как можно заметить, при наведении на кнопку меняются некоторые свойства кнопки: цвет, фон, ширина рамки и т.п. Поэтому для любой фигуры характерны следующие свойства:
1. Расположение на экране - координаты объекта
2. Размер объекта
3. Ширина рамки вокруг геометрической фигуры
4. Содержимое объекта
5. Доступность кнопки(возможность нажатия или ввода данных)
6. Цвет фигуры
7. Цвет рамки вокруг фигуры

Далее фантазия ваша, вы можете из простейших элементов создавать свои объекты. Это было краткое введение в принципы построения графики.
При работе с библиотекой SFML вы можете столкнуться с такими объектами, как:
1. RectagleShape -  геометрический объект, прямоугольник
2. CircleShape - геометрический объект, круг
3. Texture - это обычная картинка, которая накладывается на двумерный объект
4. Sprite - это любая геометрическая фигура с нанесенной поверх нее текстурой

В данном плане `RectagleShape` и `CircleShape` максимально близки по смыслу, так как являются простейшими фигурами. На примере объекта `RectagleShape` рассмотрим основные свойства фигуры:

```c++
RectagleShape rectagle;
rectagle.setPosition(50,50); //устанавливаем кординаты фигуры (x,y)
rectagle.setFillColor(sf::Color::Red); //задаём цвет внутри фигуры - красный
rectagle.setOutlineColor(sf::Color::Black); //задаём цвет рамки вокруг фигуры
rectagle.setOutlineThickness(1);// задаём ширину рамки вокруг фигуры
sf::Vector2f vector(20,20);// создаём двумерный вектор, который будет описывать размеры фигуры: ширина и длинна
rectagle.setSize(vector).// задаём размер фигуры с помощью созданного вектора
```

Кроме методов `set...`,которые устанавливают свойства фигуры, существуеют методы `get...`, которые позволяют получить конкретные свойства данной фигуры. На примере выше созданного объекта получим цвет внутри фигуры:

```c++
sf::Color colorRed = rectagle.getFillColor();// получаем цвет фигуры, в данном случае он красный
```

Объекты `Texture` и `Sprite` используются вместе. Рассмотрим работу с ними исходя из их описания.

```c++
sf::Texture texture;// создаём текстуру, которая будет являться изображением
texture.loadFromFile("car.png");// загружаем изображение из файла в текстуру. Также вы можете загружать текстуру, как массив байт
sf::Sprite sprite(texture);//наносим на поверхность фигуры текстуру.
``` 

Незабывайте, что отобразить созданный объект в вашем окне можно с помощью команды ```window.draw(rectagle)```. 
